#!/usr/bin/env python
# coding: utf-8

# In[ ]:


#The json file is the initial data from the out.txt(s) converted to a json file(Same format as a python/sagemath dictionary
#The format of an entry in the json file is as follows
# "out1.txt": {
#         "n": n,
#         "c": c,
#         "secret1": secret1,
#         "secret2": secret2,
#         "index": Same as the number right after out(1 in this case)
#     }

dictionary = #Input the contents of the json file

#Stores each password in correct order, the range part is to make it the correct size
password_list = [1 for i in range(48)]

#Runs a for loop for each out.txt provided
for out in dictionary.keys():
    global passwords_cracked
    #The next 6 lines unpack all the data from the dictionary and initialize the public key e
    n = dictionary[out]['n']
    e = 65537
    c = dictionary[out]['c']
    secret1 = dictionary[out]['secret1']
    secret2 = dictionary[out]['secret2']
    index = dictionary[out]['index'] - 1 #This is especially important, as it will later ensure all the passwords are in correct order
    #When the json file is initially generated, the out.txt entries are in incorrect order, so this is essential

    #We calculate the value of 4th root of n. This is because of the way the 2 primes, p and q, are generated
    #p and q are generated by adding the 4th power of a 512 bit integer alongwith a 16 bit integer. This means that the final prime, p, is very close to a perfect 4th power
    #Consequently, the same holds for n
    k_approx = floor(n^(1/4))
    found = False
    #delta accounts for the slight increase in k that may have been caused by the addition of the 16 bit integers. A sufficiently high delta will cover all cases
    for delta in range(0, 1001):
        #Adding delta to k
        k_val = k_approx + delta
        #The next few lines generate a degree 8 polynomial in a, which is obtained by eliminating b^4 from the expression obtained by writing n = p*q and writing p and q as the sum of the 4th
        #power and the 16 bit integers (secret1 and secret2)
        R.<a> = PolynomialRing(ZZ)
        poly = secret2 * a^8 + (k_val^4 + secret1*secret2 - n) * a^4 + secret1 * k_val^4
        #Returns all the integral roots of the generated polynomial
        roots = poly.roots()
        for a_val, times in roots:
            #Filtering out all negative roots
            if a_val > 0:
                #Generating a possible candidate for p
                p_candidate = a_val^4 + secret1
                #Quick and easy check if p is actually a factor of n
                #Since n is the product of 2 primes, it can have at most 4 factors, we need not worry about any number other than p or q dividing them
                if n % p_candidate == 0:
                    p = p_candidate
                    #Calculating q using p
                    q = n // p
                    #Stopping the search
                    found = True
                    break
        if found:
            break

    if found:
        #The following lines are the standard procedure to decode cipher text after obtaining p and q in RSA Algorithm
        phi = (p-1)*(q-1)
        d = inverse_mod(e, phi)
        m = pow(c, d, n)
        #Converting m to binary
        password = int(m).to_bytes((int(m).bit_length()+7)//8, 'big')
        #Adding the decoded (uses 'utf-8' by default) password to the array in the correct position(The position is decided by the unpacked index value in every entry)
        password_list[index] = password.decode()
    else:
        #Debug statement
        print("Failed")
        
#Outputs all the contents(passwords) of the array, in seperate lines
print('\n'.join(password_list))

